function getOffsets(e, t) {
    let s = .866 * e,
        r = e,
        a = [];
    board = (e => {
        switch (e) {
            case "normal":
                board.tiles_per_row = [3, 4, 5, 4, 3], board.row_step = .73 * r, board.center_row = Math.floor(board.tiles_per_row.length / 2), board.cell_step = .99 * s;
                break;
            case "expanded":
                board.tiles_per_row = [1, 2, 3, 4, 3, 4, 3, 4, 3, 2, 1], board.center_row = Math.floor(board.tiles_per_row.length / 2), board.cell_step = 1.51 * r * .99, board.row_step = s / 1.99
        }
        return board
    })(t);
    for (let e = 0; e < board.tiles_per_row.length; e++) {
        var o = e,
            d = board;
        row_level = o - Number(d.center_row), y_coordinate = 50 + row_level * d.row_step, x_is_even_shift = o % 2 * d.cell_step / 2, x_first_cell_shift = Math.floor(d.tiles_per_row[o] / 2) * d.cell_step;
        for (let e = 0; e < d.tiles_per_row[o]; e++) x_coordinate = 50 - x_first_cell_shift + x_is_even_shift + e * d.cell_step, a.push(`left:${x_coordinate}%;top:${y_coordinate}%`)
    }
    return a
}
let getAdjList = e => {
        adjacencyList = "normal" == e ? {
            0: [1, 3, 4],
            1: [0, 2, 4, 5],
            2: [1, 5, 6],
            3: [0, 4, 7, 8],
            4: [0, 1, 3, 5, 8, 9],
            5: [1, 2, 4, 6, 9, 10],
            6: [2, 5, 10, 11],
            7: [3, 8, 12],
            8: [3, 4, 7, 9, 12, 13],
            9: [4, 5, 8, 10, 13, 14],
            10: [5, 6, 9, 11, 14, 15],
            11: [6, 10, 15],
            12: [7, 8, 13, 16],
            13: [8, 9, 12, 14, 16, 17],
            14: [9, 10, 13, 15, 17, 18],
            15: [10, 11, 14, 18],
            16: [12, 13, 17],
            17: [13, 14, 16, 18],
            18: [14, 15, 17]
        } : {
            0: [1, 2, 4],
            1: [3, 4, 7],
            2: [4, 5, 8],
            3: [6, 7, 10],
            4: [7, 8, 11],
            5: [8, 9, 12],
            6: [3, 10, 13],
            7: [1, 3, 4, 10, 11, 14],
            8: [2, 4, 5, 11, 12, 15],
            9: [5, 12, 16],
            10: [3, 6, 7, 13, 14, 17],
            11: [4, 7, 8, 14, 15, 18],
            12: [5, 8, 9, 15, 16, 19],
            13: [6, 10, 17, 20],
            14: [7, 10, 11, 17, 18, 21],
            15: [8, 11, 12, 18, 19, 22],
            16: [9, 12, 19, 23],
            17: [10, 13, 14, 20, 21, 24],
            18: [11, 14, 15, 21, 22, 25],
            19: [12, 15, 16, 22, 23, 26],
            20: [13, 17, 24],
            21: [14, 17, 18, 24, 25, 27],
            22: [15, 18, 19, 25, 26, 28],
            23: [16, 19, 26],
            24: [17, 20, 21, 27],
            25: [18, 21, 22, 27, 28, 29],
            26: [19, 22, 23, 28],
            27: [21, 24, 25, 29],
            28: [22, 25, 26, 29],
            29: [25, 27, 28]
        }
    },
    normalSize = (state = {
        numArray: [2, 3, 3, 4, 4, 5, 5, 6, 6, 8, 8, 9, 9, 10, 10, 11, 11, 12],
        regNums: [, 3, 4, 5, 9, 10, 11],
        expandednumArray: [2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12],
        resourceArray: ["ore", "ore", "ore", "brick", "brick", "brick", "sheep", "sheep", "sheep", "sheep", "wood", "wood", "wood", "wood", "wheat", "wheat", "wheat", "wheat"],
        expandedresourceArray: ["ore", "ore", "ore", "ore", "ore", "brick", "brick", "brick", "brick", "brick", "sheep", "sheep", "sheep", "sheep", "sheep", "sheep", "wood", "wood", "wood", "wood", "wood", "wood", "wheat", "wheat", "wheat", "wheat", "wheat", "wheat"],
        prob: ["", "", ".", "..", "...", "....", ".....", "", ".....", "....", "...", "..", "."]
    }, 17.5),
    expandedSize = 16,
    resourceTypes = ["ore", "sheep", "brick", "wood", "wheat", "desert"],
    adjacencyList, size, modeElement = document.getElementById("selected-map"),
    imageTypeElement = document.getElementById("image_option_input"),
    IMAGETHEMECHOSEN = "",
    mode, shuftype = (mode = null == modeElement ? "normal" : modeElement.value, size = "normal" == mode ? normalSize : expandedSize, "random"),
    adjacent_6_8 = !1,
    adjacent_2_12 = !1,
    adjacent_same_numbers = !1,
    adjacent_same_resource = !1,
    andrew_method = !0
    settingAdjusted = !1,
    setMenuValues = () => {
        document.getElementById("andrew_method").checked = andrew_method, document.getElementById("adjacent_6_8_input").checked = adjacent_6_8, document.getElementById("adjacent_2_12_input").checked = adjacent_2_12, document.getElementById("adjacent_same_numbers_input").checked = adjacent_same_numbers, document.getElementById("adjacent_same_resource_input").checked = adjacent_same_resource, "" == IMAGETHEMECHOSEN ? document.getElementById("image_option_input").value = "newAssets" : document.getElementById("image_option_input").value = IMAGETHEMECHOSEN
    },
    tileOffsetCSS = getOffsets(size, mode),
    shuffle = t => {
        for (let e = t.length - 1; 0 < e; e--) {
            var s = Math.floor(Math.random() * (e + 1));
            [t[e], t[s]] = [t[s], t[e]]
        }
        return t
    },
    selectShuffle = () => {
        shuftype = document.getElementById("pick-shuffle").value, console.log(shuftype), start()
    },
    selectMode = () => {
        mode = document.getElementById("pick-mode").value, size = "normal" == mode ? normalSize : expandedSize, flipSameResourceSetting(), tileOffsetCSS = getOffsets(size, mode), start()
    },
    toggleDisplaySetting = e => {
        var t = document.styleSheets[0].cssRules;
        if ("switchimages" === e) {
            selectedImageStyle = document.getElementById("image_option_input").value, IMAGETHEMECHOSEN = selectedImageStyle;
            for (var s of resourceTypes)
                for (var r = "." + s, a = 0; a < t.length; a++) {
                    var o = t[a];
                    o.selectorText === r && (o.style.backgroundImage = ` url(./${selectedImageStyle}/${s}.png)`)
                }
        }
    },
    toggleSetting = e => {
        switch (settingAdjusted = !0, e) {
            case "6_8":
                adjacent_6_8 = document.getElementById("adjacent_6_8_input").checked;
                break;
            case "2_12":
                adjacent_2_12 = document.getElementById("adjacent_2_12_input").checked;
                break;
            case "same_number":
                adjacent_same_numbers = document.getElementById("adjacent_same_numbers_input").checked;
                break;
            case "same_resource":
                adjacent_same_resource = document.getElementById("adjacent_same_resource_input").checked;
            case "andrew_method":
                andrew_method = document.getElementById("andrew_method").checked;
        }
    },
    passedAdjacencyTest = (e, t, s) => {
        for (var [r, a] of e.entries())
            if (a.chit == t || a.chit == s)
                for (adj of adjacencyList[r])
                    if (e[adj].chit == t || e[adj].chit == s) return !1;
        return !0
    },
    passedBalancedCheck = e => !0,
    passedResourceCheck = (t, s) => {
        for (var [r, a] of t.entries()) {
            var o = a.resource;
            let e = 1;
            for (adj of adjacencyList[r]) o == t[adj].resource && e++;
            if (e > s) return !1
        }
        return !0
    },
    generateTileContent = () => {
        let e, t;
        t = "normal" == mode ? (e = shuffle(this.state.numArray), shuffle(this.state.resourceArray)) : (e = shuffle(this.state.expandednumArray), shuffle(this.state.expandedresourceArray));
        var s, r = this.state.prob,
            a = [];
        for (s in e) {
            var o = Object();
            o.chit = e[s], o.resource = t[s], o.probability = r[o.chit], a.push(o)
        }
        
        // Add desert tile depending on shuffle type
        var d = Object();
        d.resource = "desert", d.chit = "", d.probability = "";
        
        if (andrew_method) {
            
            // Condition 1:
            // Step 2: Find all tiles with ore and brick resources
            let oreTiles = a.filter(tile => tile.resource === "ore");
            let brickTiles = a.filter(tile => tile.resource === "brick");
            
            // Step 3: Find all tiles with chit values of 6 or 8 (high probability)
            let highProbabilityTiles = a.filter(tile => tile.chit === 6 || tile.chit === 8);
            
            // Step 4: If ore doesn't have a high probability tile, assign one
            let oreHasHighProb = oreTiles.some(tile => tile.chit === 6 || tile.chit === 8);
            if (!oreHasHighProb && highProbabilityTiles.length > 0 && oreTiles.length > 0) {
                // Find a high probability tile that's not on ore or brick
                let highProbTile = highProbabilityTiles.find(tile => 
                    tile.resource !== "ore" && tile.resource !== "brick");
                
                if (highProbTile) {
                    // Swap the chit values between the high prob tile and an ore tile
                    let oreTile = oreTiles[0];
                    let tempChit = oreTile.chit;
                    let tempProb = oreTile.probability;
                    
                    oreTile.chit = highProbTile.chit;
                    oreTile.probability = highProbTile.probability;
                    
                    highProbTile.chit = tempChit;
                    highProbTile.probability = tempProb;
                }
            }
            
            // Step 5: If brick doesn't have a high probability tile, assign one
            let brickHasHighProb = brickTiles.some(tile => tile.chit === 6 || tile.chit === 8);
            if (!brickHasHighProb && highProbabilityTiles.length > 0 && brickTiles.length > 0) {
                // Find a high probability tile that's not on ore or brick (after previous swaps)
                let highProbTile = highProbabilityTiles.find(tile => 
                    tile.resource !== "ore" && tile.resource !== "brick");
                
                if (highProbTile) {
                    // Swap the chit values between the high prob tile and a brick tile
                    let brickTile = brickTiles[0];
                    let tempChit = brickTile.chit;
                    let tempProb = brickTile.probability;
                    
                    brickTile.chit = highProbTile.chit;
                    brickTile.probability = highProbTile.probability;
                    
                    highProbTile.chit = tempChit;
                    highProbTile.probability = tempProb;
                }
            }

            //Condition 2: No same number on same resource
            for (let res of ['ore', 'wood', 'brick', 'sheep', 'wheat']){
                // console.log(res)
                let resTiles = a.filter(tile => tile.resource === res);
                let hasDuplicates = false
                let dupeEle = null
                let dupeProb = null
                for (let i=0; i<resTiles.length; i++){
                    for (let j=i+1; j<resTiles.length; j++){
                        if (resTiles[i].chit === resTiles[j].chit){
                            hasDuplicates = true
                            dupeProb = getProbabilityValue(resTiles[j].chit)
                            dupeEle = resTiles[j]
                            break
                        }
                    }
                }
                if (hasDuplicates){
                    let diffProbTile = a.find(tile => 
                        tile.resource !== res && getProbabilityValue(tile.chit) !== dupeProb);
                    
                    let tempChit = diffProbTile.chit;
                    let tempProb = diffProbTile.probability;
                    
                    diffProbTile.chit = dupeEle.chit;
                    diffProbTile.probability = dupeEle.probability;
                    
                    dupeEle.chit = tempChit;
                    dupeEle.probability = tempProb;
                }
            }
            
            // Step 6: Shuffle the final array
            a = shuffle(a);

            // Step 1: Add the desert tile(s) first
            // a.push(d);
            a.splice(9, 0, d);
            if ("expanded" == mode) {
                a.push(d);
            }

        } else {
            // Original behavior - add desert at the end and shuffle everything
            a.push(d);
            if ("expanded" == mode) {
                a.push(d);
            }
            a = shuffle(a);
        }
        
        return a;
    },
    buildTiles = () => {
        document.getElementById("board").innerHTML = `<div class="${mode}BorderCommon border-${mode}"></div>`;
        for (var [e, t] of tileOffsetCSS.entries()) document.getElementById("board").innerHTML += `<div class="hex-${mode} hex-base" style="${t}" id="tile-${e}")>
                  <div class="circle-${mode} circle-base font-size-wrap" id="circle-${e}">
                  </div>
              </div>`
    },

    shuffleIsValid = e => {
        console.log("Before condition 2 check" + (andrew_method));
        // For andrew_method, we need to validate desert placement and the additional conditions
        if (andrew_method) {
            // Get the middle tile index
            let middleIndex = "normal" == mode ? 9 : 14;
            
            // // Verify desert is in middle position
            // if (e[middleIndex].resource !== "desert") {
            //     return false;
            // }
            
            // Condition 1: Each resource should have roughly equal probability
            const resourceProbabilities = {};
            resourceTypes.forEach(type => {
                if (type !== "desert") resourceProbabilities[type] = 0;
            });
            
            // Calculate total probability for each resource type
            e.forEach(tile => {
                if (tile.resource !== "desert" && tile.chit) {
                    // Convert chit to probability value (approximate)
                    const probValue = getProbabilityValue(tile.chit);
                    resourceProbabilities[tile.resource] += probValue;
                }
            });
            
            // Check if probabilities are roughly equal
            const probValues = Object.values(resourceProbabilities);
            const avgProb = probValues.reduce((sum, val) => sum + val, 0) / probValues.length;
            const threshold = avgProb * 0.25; // Allow 25% deviation from average
            
            for (const prob of probValues) {
                if (Math.abs(prob - avgProb) > threshold) {
                    return false;
                }
            }
            
            // // Condition 2: A same number should not be on two tiles of the same resource
            // const resourceNumberPairs = new Set();
            
            // for (const tile of e) {
            //     if (tile.resource !== "desert" && tile.chit) {
            //         const pair = `${tile.resource}-${tile.chit}`;
            //         if (resourceNumberPairs.has(pair)) {
            //             return false;
            //         }
            //         resourceNumberPairs.add(pair);
            //     }
            // }
        }
        
        let t = !0;
        if (t = adjacent_same_resource || "normal" != mode ? t && passedResourceCheck(e, 2) : t && passedResourceCheck(e, 1), !adjacent_6_8 && !(t = t && passedAdjacencyTest(e, 6, 8))) return !1;
        if (adjacent_2_12 || (t = t && passedAdjacencyTest(e, 2, 12)), !adjacent_same_numbers)
            for (var s of state.regNums)
                if (!(t = t && passedAdjacencyTest(e, s, s))) return !1;
        return t
    };
    
    // Helper function to convert chit numbers to approximate probability values
    function getProbabilityValue(chit) {
        // Based on the probability of rolling each number with 2 dice
        const probMap = {
            2: 1, 
            3: 2,
            4: 3,
            5: 4,
            6: 5,
            8: 5,
            9: 4,
            10: 3,
            11: 2,
            12: 1
        };
        return probMap[chit] || 0;
    };

    fillTiles = () => {
        let e;
        for (; e = generateTileContent(), !shuffleIsValid(e););
        for (var [t, s] of e.entries()) {
            var r, a = document.getElementById("tile-" + t),
                t = document.getElementById("circle-" + t);
            for (r of a.classList)
                if (resourceTypes.includes(r)) {
                    a.classList.remove(r);
                    break
                } a.classList.add(s.resource), a.setAttribute("alt", s.resource), t.innerHTML = `<div class="tile-chit-${mode} chit-number-base">${s.chit}</div>`, 8 == s.chit || 6 == s.chit ? a.classList.add("high-prob") : a.classList.remove("high-prob"), "desert" == s.resource ? t.classList.add("desert-chit") : (t.classList.remove("desert-chit"), t.innerHTML += `<div class="prob-dots-base small-font-size-wrap">${s.probability}<div/>`)
        }
    },
    generateBoard = () => {
        event.preventDefault(), fillTiles()
    },
    flipSameResourceSetting = () => {
        var e = document.getElementById("sameResourceSetting").classList;
        "normal" == mode ? e.remove("settingViewToggle") : e.add("settingViewToggle")
    },
    optionsPopup = document.getElementById("popmenu"),
    toggleOptions = (document.addEventListener("mousedown", function(e) {
        optionsPopup.contains(e.target) || document.getElementById("popmenu").classList.contains("hidden") || toggleOptions()
    }), () => {
        var e = document.getElementById("popmenu").classList,
            t = document.getElementById("overlay").classList;
        flipSameResourceSetting(), t.contains("hidden") ? (t.remove("hidden"), t.add("overLay")) : (t.add("hidden"), t.remove("overLay")), e.contains("hidden") ? (e.remove("hidden"), setMenuValues()) : (e.add("hidden"), settingAdjusted && (settingAdjusted = !1, generateBoard()))
    }),
    start = () => {
        getAdjList(mode), buildTiles(mode), fillTiles()
    };
start();